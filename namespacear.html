<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>github.com/RhysU/ar: ar Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">github.com/RhysU/ar</div>
   <div id="projectbrief">Autoregressive process modeling tools in header-only C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">ar Namespace Reference</div>  </div>
</div>
<div class="contents">

<p>Autoregressive process modeling tools in header-only C++.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1predictor.html">predictor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate an autoregressive model process with an InputIterator interface.  <a href="classar_1_1predictor.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1mean__subtracted.html">mean_subtracted</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Method-specific estimation variance routines following Broersen.  <a href="structar_1_1mean__subtracted.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1mean__retained.html">mean_retained</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes the sample mean was retained in a signal during estimation.  <a href="structar_1_1mean__retained.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1estimation__method.html">estimation_method</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A parent type for autoregressive process parameter estimation techniques.  <a href="structar_1_1estimation__method.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1YuleWalker.html">YuleWalker</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents estimation by solving the Yule--Walker equations.  <a href="classar_1_1YuleWalker.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1Burg.html">Burg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents estimation using Burg's recursive method.  <a href="classar_1_1Burg.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1LSFB.html">LSFB</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents forward and backward prediction least squares minimization.  <a href="classar_1_1LSFB.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1LSF.html">LSF</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents forward prediction least squares minimization.  <a href="classar_1_1LSF.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1empirical__variance__function.html">empirical_variance_function</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL-ready binary_function for a given method's empirical variance.  <a href="structar_1_1empirical__variance__function.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1empirical__variance__generator.html">empirical_variance_generator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL AdaptableGenerator for a given method's empirical variance.  <a href="classar_1_1empirical__variance__generator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1empirical__variance__iterator.html">empirical_variance_iterator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable RandomAccessIterator over a method's empirical variance sequence.  <a href="classar_1_1empirical__variance__iterator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1criterion.html">criterion</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Criteria for autoregressive model order selection following Broersen.  <a href="structar_1_1criterion.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1GIC.html">GIC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the generalized information criterion (<a class="el" href="structar_1_1GIC.html" title="Represents the generalized information criterion (GIC).">GIC</a>).  <a href="structar_1_1GIC.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1AIC.html">AIC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the Akaike information criterion (<a class="el" href="structar_1_1AIC.html" title="Represents the Akaike information criterion (AIC).">AIC</a>).  <a href="structar_1_1AIC.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1BIC.html">BIC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the consistent criterion <a class="el" href="structar_1_1BIC.html" title="Represents the consistent criterion BIC.">BIC</a>.  <a href="structar_1_1BIC.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1MCC.html">MCC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the minimally consistent criterion (<a class="el" href="structar_1_1MCC.html" title="Represents the minimally consistent criterion (MCC).">MCC</a>).  <a href="structar_1_1MCC.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1AICC.html">AICC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the asymptotically-corrected Akaike information criterion (<a class="el" href="structar_1_1AICC.html" title="Represents the asymptotically-corrected Akaike information criterion (AICC).">AICC</a>).  <a href="structar_1_1AICC.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1FIC.html">FIC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the finite information criterion (<a class="el" href="structar_1_1FIC.html" title="Represents the finite information criterion (FIC) as applied to a particular estimation_method.">FIC</a>) as applied to a particular <a class="el" href="structar_1_1estimation__method.html">estimation_method</a>.  <a href="structar_1_1FIC.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1FIC_3_01YuleWalker_3_01MeanHandling_01_4_00_01AlphaNumerator_00_01AlphaDenominator_01_4.html">FIC&lt; YuleWalker&lt; MeanHandling &gt;, AlphaNumerator, AlphaDenominator &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the finite information criterion (<a class="el" href="structar_1_1FIC.html" title="Represents the finite information criterion (FIC) as applied to a particular estimation_method.">FIC</a>) as applied to the <a class="el" href="classar_1_1YuleWalker.html">YuleWalker</a> <a class="el" href="structar_1_1estimation__method.html">estimation_method</a>.  <a href="structar_1_1FIC_3_01YuleWalker_3_01MeanHandling_01_4_00_01AlphaNumerator_00_01AlphaDenominator_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1FSIC.html">FSIC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the finite sample information criterion (<a class="el" href="structar_1_1FSIC.html" title="Represents the finite sample information criterion (FSIC) as applied to a particular estimation_metho...">FSIC</a>) as applied to a particular <a class="el" href="structar_1_1estimation__method.html">estimation_method</a>.  <a href="structar_1_1FSIC.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1CIC.html">CIC</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the combined information criterion (<a class="el" href="structar_1_1CIC.html" title="Represents the combined information criterion (CIC) as applied to a particular estimation_method.">CIC</a>) as applied to a particular <a class="el" href="structar_1_1estimation__method.html">estimation_method</a>.  <a href="structar_1_1CIC.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1best__model__function.html">best_model_function</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A template typedef and helper method returning a <a class="el" href="namespacear.html#ab965d88f76e1d324c16ec63eb0ca98ed">best_model</a> implementation matching a model selection criterion provided at runtime.  <a href="structar_1_1best__model__function.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1strided__adaptor.html">strided_adaptor</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An adapter to add striding over another (usually random access) iterator.  <a href="classar_1_1strided__adaptor.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputType1 , typename OutputType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#aa374873fb73eca704b72467f58a2a109">welford_nvariance</a> (InputIterator first, InputIterator last, OutputType1 &amp;mean, OutputType2 &amp;nvar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable, one-pass algorithms for computing variances and covariances.  <a href="#aa374873fb73eca704b72467f58a2a109"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputType1 , typename OutputType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a6677588ce2c0685d9494e37d5c02209c">welford_variance_population</a> (InputIterator first, InputIterator last, OutputType1 &amp;mean, OutputType2 &amp;var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean and population variance using Welford's algorithm.  <a href="#a6677588ce2c0685d9494e37d5c02209c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputType1 , typename OutputType2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a0df60aec47c7067dfe51d0892db50856">welford_variance_sample</a> (InputIterator first, InputIterator last, OutputType1 &amp;mean, OutputType2 &amp;var)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean and sample variance using Welford's algorithm.  <a href="#a0df60aec47c7067dfe51d0892db50856"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType1 , typename OutputType2 , typename OutputType3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a8a9004a99f24a6e0ac6ab2957be9e1e3">welford_ncovariance</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType1 &amp;mean1, OutputType2 &amp;mean2, OutputType3 &amp;ncovar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute means and the number of samples, N, times the population covariance using Welford's algorithm.  <a href="#a8a9004a99f24a6e0ac6ab2957be9e1e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType1 , typename OutputType2 , typename OutputType3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a82454d2988b8b9f00cc3e14836bdc44e">welford_covariance_population</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType1 &amp;mean1, OutputType2 &amp;mean2, OutputType3 &amp;covar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute means and the population covariance using Welford's algorithm.  <a href="#a82454d2988b8b9f00cc3e14836bdc44e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType1 , typename OutputType2 , typename OutputType3 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a5f8569f8d184f8facaded6fa8220a41c">welford_covariance_sample</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType1 &amp;mean1, OutputType2 &amp;mean2, OutputType3 &amp;covar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute means and the sample covariance using Welford's algorithm.  <a href="#a5f8569f8d184f8facaded6fa8220a41c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Value , class OutputIterator1 , class OutputIterator2 , class OutputIterator3 , class OutputIterator4 , class Vector &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a4464f8cff351885d447a5faada248cf6">burg_method</a> (InputIterator data_first, InputIterator data_last, Value &amp;mean, std::size_t &amp;maxorder, OutputIterator1 params_first, OutputIterator2 sigma2e_first, OutputIterator3 gain_first, OutputIterator4 autocor_first, const bool subtract_mean, const bool hierarchy, Vector &amp;f, Vector &amp;b, Vector &amp;Ak, Vector &amp;ac)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithms for autoregressive parameter estimation and manipulation.  <a href="#a4464f8cff351885d447a5faada248cf6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Value , class OutputIterator1 , class OutputIterator2 , class OutputIterator3 , class OutputIterator4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a8092b6678796a06c048dd89153273f60">burg_method</a> (InputIterator data_first, InputIterator data_last, Value &amp;mean, std::size_t &amp;maxorder, OutputIterator1 params_first, OutputIterator2 sigma2e_first, OutputIterator3 gain_first, OutputIterator4 autocor_first, const bool subtract_mean=false, const bool hierarchy=false)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator , class InputIterator , class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classar_1_1predictor.html">predictor</a>&lt; typename <br class="typebreak"/>
std::iterator_traits<br class="typebreak"/>
&lt; RandomAccessIterator &gt;<br class="typebreak"/>
::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#ad78566f1c965c4194cd93a5325544107">autocorrelation</a> (RandomAccessIterator params_first, RandomAccessIterator params_last, Value gain, InputIterator autocor_first)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator over the autocorrelation function \(\rho_k\) given process parameters and initial conditions.  <a href="#ad78566f1c965c4194cd93a5325544107"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a86e63cb630fb0520b27ca3d266575d7d">decorrelation_time</a> (const std::size_t N, <a class="el" href="classar_1_1predictor.html">predictor</a>&lt; Value &gt; rho, const bool abs_rho=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the decorrelation time for variance of the mean given autocorrelation details.  <a href="#a86e63cb630fb0520b27ca3d266575d7d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a65c0f6de77f3f7c59292e3f7b61c833d">decorrelation_time</a> (const std::size_t N, <a class="el" href="classar_1_1predictor.html">predictor</a>&lt; Value &gt; rho1, <a class="el" href="classar_1_1predictor.html">predictor</a>&lt; Value &gt; rho2, const bool abs_rho=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the decorrelation time for a covariance given autocorrelation details from two processes.  <a href="#a65c0f6de77f3f7c59292e3f7b61c833d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator , class InputIterator , class OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a70e8c90d3cdf5f3cf0a61e00751558b8">zohar_linear_solve</a> (RandomAccessIterator a_first, RandomAccessIterator a_last, RandomAccessIterator r_first, InputIterator d_first, OutputIterator s_first)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a Toeplitz set of linear equations.  <a href="#a70e8c90d3cdf5f3cf0a61e00751558b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator , class ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#abca89c351017c0a7854258f4d5228221">zohar_linear_solve</a> (RandomAccessIterator a_first, RandomAccessIterator a_last, RandomAccessIterator r_first, ForwardIterator d_first)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a Toeplitz set of linear equations in-place.  <a href="#abca89c351017c0a7854258f4d5228221"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator , class ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#acb2d3771cb68bf77ddb8522eabf72c90">zohar_linear_solve</a> (RandomAccessIterator a_first, RandomAccessIterator a_last, ForwardIterator d_first)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a real-valued, symmetric Toeplitz set of linear equations in-place.  <a href="#acb2d3771cb68bf77ddb8522eabf72c90"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Criterion , typename Result , typename Integer1 , typename Integer2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#ac6649976e2fc0f7e0b6f80e48a2a5670">evaluate</a> (Result sigma2e, Integer1 N, Integer2 p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a given <a class="el" href="structar_1_1criterion.html">criterion</a> for <code>N</code> samples and model order <code>p</code>.  <a href="#ac6649976e2fc0f7e0b6f80e48a2a5670"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Criterion , typename Integer1 , typename Integer2 , class InputIterator , class OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#a299e4eda569cae92a2a5192da4f2b6cb">evaluate_models</a> (Integer1 N, Integer2 ordfirst, InputIterator first, InputIterator last, OutputIterator crit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithmic helpers for autoregressive model order selection.  <a href="#a299e4eda569cae92a2a5192da4f2b6cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Criterion , typename Integer , class Sequence1 , class Sequence2 , class Sequence3 , class Sequence4 , class OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Sequence1::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#ab965d88f76e1d324c16ec63eb0ca98ed">best_model</a> (Integer N, Sequence1 &amp;params, Sequence2 &amp;sigma2e, Sequence3 &amp;gain, Sequence4 &amp;autocor, OutputIterator crit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the best model according to <a class="el" href="structar_1_1criterion.html">criterion</a> applied to \(\sigma^2_\epsilon\) given a hierarchy of candidates.  <a href="#ab965d88f76e1d324c16ec63eb0ca98ed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Criterion , typename Integer1 , typename Integer2 , class InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#ad337dfbd7bde87898f1f1206ef100d6c">evaluate_models</a> (Integer1 N, Integer2 ordfirst, InputIterator first, InputIterator last)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the best model from a hierarchy of candidates according to a <a class="el" href="structar_1_1criterion.html">criterion</a> given \(\sigma^2_\epsilon\) for each model.  <a href="#ad337dfbd7bde87898f1f1206ef100d6c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Criterion , typename Integer , class Sequence1 , class Sequence2 , class Sequence3 , class Sequence4 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Sequence1::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacear.html#af20405841b25365abcfc1aeb6add8069">best_model</a> (Integer N, Sequence1 &amp;params, Sequence2 &amp;sigma2e, Sequence3 &amp;gain, Sequence4 &amp;autocor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the best model according to <a class="el" href="structar_1_1criterion.html">criterion</a> applied to \(\sigma^2_\epsilon\) given a hierarchy of candidates.  <a href="#af20405841b25365abcfc1aeb6add8069"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Autoregressive process modeling tools in header-only C++. </p>
<p>All routines estimate and/or evaluate autoregressive models of the form </p>
<p class="formulaDsp">
\begin{align} x_n + a_1 x_{n - 1} + \dots + a_p x_{n - p} &amp;= \epsilon_n &amp; \epsilon_n &amp;\sim{} N\left(0, \sigma^2_\epsilon\right) \\ \sigma^2_x \left( \rho_0 + a_1 \rho_{1} + \dots + a_p \rho_{p} \right) &amp;= \sigma^2_\epsilon &amp; \rho_0 &amp;= 1 \\ \rho_k + a_1 \rho_{k-1} + \dots + a_p \rho_{k-p} &amp;= 0 &amp; k &amp;\geq{} p \end{align}
</p>
<p> where \(x_i\) are the process values, \(a_i\) are the model parameters, and \(\rho_i\) are the lag \(i\) autocorrelations. The white noise input process \(\epsilon_n\) has variance \(\sigma^2_\epsilon\). The model has output variance \(\sigma^2_x\) and therefore a gain equal to \(\sigma^2_x / \sigma^2_\epsilon\). </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad78566f1c965c4194cd93a5325544107"></a><!-- doxytag: member="ar::autocorrelation" ref="ad78566f1c965c4194cd93a5325544107" args="(RandomAccessIterator params_first, RandomAccessIterator params_last, Value gain, InputIterator autocor_first)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class InputIterator , class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classar_1_1predictor.html">predictor</a>&lt;typename std::iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt; ar::autocorrelation </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>params_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>params_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>autocor_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct an iterator over the autocorrelation function \(\rho_k\) given process parameters and initial conditions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">params_first</td><td>Beginning of range containing \(a_1,\dots,a_p\). </td></tr>
    <tr><td class="paramname">params_last</td><td>Exclusive ending of the parameter range. </td></tr>
    <tr><td class="paramname">gain</td><td>The model gain \(\sigma^2_x / \sigma^2_\epsilon\). </td></tr>
    <tr><td class="paramname">autocor_first</td><td>Beginning of range containing \(\rho_0,...\rho_p\).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An InputIterator across the autocorrelation function starting with \(\rho_0\). </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00853">853</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab965d88f76e1d324c16ec63eb0ca98ed"></a><!-- doxytag: member="ar::best_model" ref="ab965d88f76e1d324c16ec63eb0ca98ed" args="(Integer N, Sequence1 &amp;params, Sequence2 &amp;sigma2e, Sequence3 &amp;gain, Sequence4 &amp;autocor, OutputIterator crit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer , class Sequence1 , class Sequence2 , class Sequence3 , class Sequence4 , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Sequence1::difference_type ar::best_model </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence1 &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence2 &amp;&#160;</td>
          <td class="paramname"><em>sigma2e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence3 &amp;&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence4 &amp;&#160;</td>
          <td class="paramname"><em>autocor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>crit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the best model according to <a class="el" href="structar_1_1criterion.html">criterion</a> applied to \(\sigma^2_\epsilon\) given a hierarchy of candidates. </p>
<p>On input, <code>params</code>, <code>sigma2e</code>, <code>gain</code>, and <code>autocor</code> should be <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>s which were populated by <a class="el" href="namespacear.html#a4464f8cff351885d447a5faada248cf6">burg_method</a> when <code>hierarchy</code> is <code>true</code> (or in some other equivalent manner). On output, these arguments will contain only values relevant to the best model.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). For example, the return value of <a class="el" href="namespacear.html#a4464f8cff351885d447a5faada248cf6">burg_method</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">params</td><td>Model parameters </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sigma2e</td><td>\(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gain</td><td>Model gain </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">autocor</td><td>Model autocorrelations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crit</td><td>Value assigned to each model by the criterion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the best criterion value within <code>crit</code>. </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l02065">2065</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af20405841b25365abcfc1aeb6add8069"></a><!-- doxytag: member="ar::best_model" ref="af20405841b25365abcfc1aeb6add8069" args="(Integer N, Sequence1 &amp;params, Sequence2 &amp;sigma2e, Sequence3 &amp;gain, Sequence4 &amp;autocor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer , class Sequence1 , class Sequence2 , class Sequence3 , class Sequence4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Sequence1::difference_type ar::best_model </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence1 &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence2 &amp;&#160;</td>
          <td class="paramname"><em>sigma2e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence3 &amp;&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence4 &amp;&#160;</td>
          <td class="paramname"><em>autocor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Obtain the best model according to <a class="el" href="structar_1_1criterion.html">criterion</a> applied to \(\sigma^2_\epsilon\) given a hierarchy of candidates. </p>
<p>On input, <code>params</code>, <code>sigma2e</code>, <code>gain</code>, and <code>autocor</code> should be <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>s which were populated by <a class="el" href="namespacear.html#a4464f8cff351885d447a5faada248cf6">burg_method</a> when <code>hierarchy</code> is <code>true</code> (or in some other equivalent manner). On output, these arguments will contain only values relevant to the best model.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). For example, the return value of <a class="el" href="namespacear.html#a4464f8cff351885d447a5faada248cf6">burg_method</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">params</td><td>Model parameters </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sigma2e</td><td>\(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gain</td><td>Model gain </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">autocor</td><td>Model autocorrelations</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the best model within the inputs.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>best_model(Integer,Sequence1,Sequence2,Sequence3,Sequence4,OutputIterator) </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l02200">2200</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8092b6678796a06c048dd89153273f60"></a><!-- doxytag: member="ar::burg_method" ref="a8092b6678796a06c048dd89153273f60" args="(InputIterator data_first, InputIterator data_last, Value &amp;mean, std::size_t &amp;maxorder, OutputIterator1 params_first, OutputIterator2 sigma2e_first, OutputIterator3 gain_first, OutputIterator4 autocor_first, const bool subtract_mean=false, const bool hierarchy=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Value , class OutputIterator1 , class OutputIterator2 , class OutputIterator3 , class OutputIterator4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::burg_method </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>data_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>data_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>maxorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>params_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>sigma2e_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator3&#160;</td>
          <td class="paramname"><em>gain_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator4&#160;</td>
          <td class="paramname"><em>autocor_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>subtract_mean</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hierarchy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Algorithms for autoregressive parameter estimation and manipulation. </p>
<p>Fit an autoregressive model to stationary time series data using Burg's method. That is, find coefficients \(a_i\) such that the sum of the squared errors in the forward predictions \(x_n = -a_1 x_{n-1} - \dots - a_p x_{n-p}\) and backward predictions \(x_n = -a_1 x_{n+1} - \dots - a_p x_{n+p}\) are both minimized. Either a single model of given order or a hierarchy of models up to and including a maximum order may fit.</p>
<p>The input data \(\vec{x}\) are read from <code>[data_first, data_last)</code> in a single pass. The mean is computed, returned in <code>mean</code>, and <em>removed</em> from further consideration whenever <code>subtract_mean</code> is true. The estimated model parameters \(a_i\) are output using <code>params_first</code> with the behavior determined by the amount of data read, <code>maxorder</code>, and the <code>hierarchy</code> flag: </p>
<ul>
<li>
If <code>hierarchy</code> is <code>false</code>, only the \(a_1, \dots, a_\text{maxorder}\) parameters for an AR(<code>maxorder</code>) process are output. </li>
<li>
If <code>hierarchy</code> is <code>true</code>, the <code>maxorder*(maxorder+1)/2</code> parameters \(a_1, \dots, a_m\) for models AR(0), AR(1), AR(2), ..., AR(maxorder) are output. Notice AR(0) has no parameters.  </li>
</ul>
<p>Note that the latter case is <em>always</em> computed; the <code>hierarchy</code> flag merely controls what is output. In both cases, the maximum order is limited by the number of data samples provided and is output to <code>maxorder</code>.</p>
<p>One mean squared discrepancy \(\sigma^2_\epsilon\), also called the innovation variance, and gain, defined as \(\sigma^2_x / \sigma^2_\epsilon\), are output for each model, including the trivial zeroth order model when <code>maxorder</code> is zero or <code>hierarchy</code> is <code>true</code>, using <code>sigma2e_first</code> and <code>gain_first</code>. The autocorrelations for lags <code>[0,k]</code> are output using <code>autocor_first</code>. When <code>hierarchy</code> is <code>true</code>, only lags <code>[0,m]</code> should be applied for some AR(<code>m</code>) model. Outputting the lag <code>k</code> autocorrelation is technically redundant as it may be computed from \(a_i\) and lags <code>0, ..., k-1</code>. Autocovariances may be computed by multiplying the autocorrelations by the gain times \(\sigma^2_\epsilon\).</p>
<p>The implementation has been refactored from Cedrick Collomb's 2009 article <a href="http://www.emptyloop.com/technotes/A%20tutorial%20on%20Burg&apos;s%20method,%20algorithm%20and%20recursion.pdf">"Burg’s
 Method, Algorithm and Recursion"</a>. In particular, iterators are employed, the working precision is selectable using <code>mean</code>, the mean squared discrepancy calculation has been added, some loop index transformations have been performed, working storage may be passed into the method to reduce allocations across many invocations, and all lower order models may be output during the recursion using <code>hierarchy</code>. Gain and autocorrelation calculations have been added based on sections 5.2 and 5.3 of Broersen, P. M. T. Automatic autocorrelation and spectral analysis. Springer, 2006. <a href="http://dx.doi.org/10.1007/1-84628-329-9.">http://dx.doi.org/10.1007/1-84628-329-9.</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">maxorder</td><td>On input, the maximum model order desired. On output, the maximum model order computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">params_first</td><td>Model parameters for a single model or for an entire hierarchy of models. At most <code>!hierarchy ? maxorder : maxorder*(maxorder+1)/2</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sigma2e_first</td><td>The mean squared discrepancy for only AR(<code>maxorder</code>) or for an entire hierarchy. Either one or at most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gain_first</td><td>The model gain for only AR(<code>maxorder</code>) or an entire hierarchy. Either one or at most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">autocor_first</td><td>Lag one through lag maxorder autocorrelations. At most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subtract_mean</td><td>Should <code>mean</code> be subtracted from the data? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hierarchy</td><td>Should the entire hierarchy of estimated models be output? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Working storage. Reuse across invocations may speed execution by avoiding allocations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Working storage similar to <code>f</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ak</td><td>Working storage similar to <code>f</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ac</td><td>Working storage similar to <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number data values processed within <code>[data_first, data_last)</code>. </dd></dl>
 
<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00516">516</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p>References <a class="el" href="ar_8hpp_source.html#l00387">burg_method()</a>.</p>

</div>
</div>
<a class="anchor" id="a4464f8cff351885d447a5faada248cf6"></a><!-- doxytag: member="ar::burg_method" ref="a4464f8cff351885d447a5faada248cf6" args="(InputIterator data_first, InputIterator data_last, Value &amp;mean, std::size_t &amp;maxorder, OutputIterator1 params_first, OutputIterator2 sigma2e_first, OutputIterator3 gain_first, OutputIterator4 autocor_first, const bool subtract_mean, const bool hierarchy, Vector &amp;f, Vector &amp;b, Vector &amp;Ak, Vector &amp;ac)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Value , class OutputIterator1 , class OutputIterator2 , class OutputIterator3 , class OutputIterator4 , class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::burg_method </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>data_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>data_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>maxorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>params_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>sigma2e_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator3&#160;</td>
          <td class="paramname"><em>gain_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator4&#160;</td>
          <td class="paramname"><em>autocor_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>subtract_mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>Ak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>ac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Algorithms for autoregressive parameter estimation and manipulation. </p>
<p>Fit an autoregressive model to stationary time series data using Burg's method. That is, find coefficients \(a_i\) such that the sum of the squared errors in the forward predictions \(x_n = -a_1 x_{n-1} - \dots - a_p x_{n-p}\) and backward predictions \(x_n = -a_1 x_{n+1} - \dots - a_p x_{n+p}\) are both minimized. Either a single model of given order or a hierarchy of models up to and including a maximum order may fit.</p>
<p>The input data \(\vec{x}\) are read from <code>[data_first, data_last)</code> in a single pass. The mean is computed, returned in <code>mean</code>, and <em>removed</em> from further consideration whenever <code>subtract_mean</code> is true. The estimated model parameters \(a_i\) are output using <code>params_first</code> with the behavior determined by the amount of data read, <code>maxorder</code>, and the <code>hierarchy</code> flag: </p>
<ul>
<li>
If <code>hierarchy</code> is <code>false</code>, only the \(a_1, \dots, a_\text{maxorder}\) parameters for an AR(<code>maxorder</code>) process are output. </li>
<li>
If <code>hierarchy</code> is <code>true</code>, the <code>maxorder*(maxorder+1)/2</code> parameters \(a_1, \dots, a_m\) for models AR(0), AR(1), AR(2), ..., AR(maxorder) are output. Notice AR(0) has no parameters.  </li>
</ul>
<p>Note that the latter case is <em>always</em> computed; the <code>hierarchy</code> flag merely controls what is output. In both cases, the maximum order is limited by the number of data samples provided and is output to <code>maxorder</code>.</p>
<p>One mean squared discrepancy \(\sigma^2_\epsilon\), also called the innovation variance, and gain, defined as \(\sigma^2_x / \sigma^2_\epsilon\), are output for each model, including the trivial zeroth order model when <code>maxorder</code> is zero or <code>hierarchy</code> is <code>true</code>, using <code>sigma2e_first</code> and <code>gain_first</code>. The autocorrelations for lags <code>[0,k]</code> are output using <code>autocor_first</code>. When <code>hierarchy</code> is <code>true</code>, only lags <code>[0,m]</code> should be applied for some AR(<code>m</code>) model. Outputting the lag <code>k</code> autocorrelation is technically redundant as it may be computed from \(a_i\) and lags <code>0, ..., k-1</code>. Autocovariances may be computed by multiplying the autocorrelations by the gain times \(\sigma^2_\epsilon\).</p>
<p>The implementation has been refactored from Cedrick Collomb's 2009 article <a href="http://www.emptyloop.com/technotes/A%20tutorial%20on%20Burg&apos;s%20method,%20algorithm%20and%20recursion.pdf">"Burg’s
 Method, Algorithm and Recursion"</a>. In particular, iterators are employed, the working precision is selectable using <code>mean</code>, the mean squared discrepancy calculation has been added, some loop index transformations have been performed, working storage may be passed into the method to reduce allocations across many invocations, and all lower order models may be output during the recursion using <code>hierarchy</code>. Gain and autocorrelation calculations have been added based on sections 5.2 and 5.3 of Broersen, P. M. T. Automatic autocorrelation and spectral analysis. Springer, 2006. <a href="http://dx.doi.org/10.1007/1-84628-329-9.">http://dx.doi.org/10.1007/1-84628-329-9.</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">maxorder</td><td>On input, the maximum model order desired. On output, the maximum model order computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">params_first</td><td>Model parameters for a single model or for an entire hierarchy of models. At most <code>!hierarchy ? maxorder : maxorder*(maxorder+1)/2</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sigma2e_first</td><td>The mean squared discrepancy for only AR(<code>maxorder</code>) or for an entire hierarchy. Either one or at most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gain_first</td><td>The model gain for only AR(<code>maxorder</code>) or an entire hierarchy. Either one or at most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">autocor_first</td><td>Lag one through lag maxorder autocorrelations. At most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subtract_mean</td><td>Should <code>mean</code> be subtracted from the data? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hierarchy</td><td>Should the entire hierarchy of estimated models be output? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Working storage. Reuse across invocations may speed execution by avoiding allocations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Working storage similar to <code>f</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ak</td><td>Working storage similar to <code>f</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ac</td><td>Working storage similar to <code>f</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number data values processed within <code>[data_first, data_last)</code>. </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00387">387</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p>References <a class="el" href="ar_8hpp_source.html#l00095">welford_nvariance()</a>.</p>

</div>
</div>
<a class="anchor" id="a86e63cb630fb0520b27ca3d266575d7d"></a><!-- doxytag: member="ar::decorrelation_time" ref="a86e63cb630fb0520b27ca3d266575d7d" args="(const std::size_t N, predictor&lt; Value &gt; rho, const bool abs_rho=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value ar::decorrelation_time </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">predictor&lt; Value &gt;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>abs_rho</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the decorrelation time for variance of the mean given autocorrelation details. </p>
<p>That is, compute </p>
<p class="formulaDsp">
\begin{align} T_0 &amp;= 1 + 2 \sum_{i=1}^{N} \left(1 - \frac{i}{N}\right) \rho_i \end{align}
</p>
<p> following Trenberth, K. E. "Some effects of finite sample size and
 persistence on meteorological statistics. Part I: Autocorrelations." Monthly Weather Review 112 (1984). <a href="http://dx.doi.org/10.1175/1520-0493(1984)112%3C2359:SEOFSS%3E2.0.CO;2">http://dx.doi.org/10.1175/1520-0493(1984)112%3C2359:SEOFSS%3E2.0.CO;2</a></p>
<p>Rather than \(\rho\), \(\left|\rho\right|\) may be used in the definition of \(T_0\) to better approximate the "decay of the correlation
 envelope" according to section 17.1.5 of Hans von Storch and Francis W. Zwiers. Statistical analysis in climate research. Cambridge University Press, March 2001. ISBN 978-0521012300. Doing so is more robust for oscillatory processes and always provides a larger, more conservative estimate of \(T_0\).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Maximum lag used to compute the autocorrelation. </td></tr>
    <tr><td class="paramname">rho</td><td>A <a class="el" href="classar_1_1predictor.html">predictor</a> iterating over the <a class="el" href="namespacear.html#ad78566f1c965c4194cd93a5325544107">autocorrelation</a>. </td></tr>
    <tr><td class="paramname">abs_rho</td><td>Use \(\left|\rho\right|\) when calculating \(T_0\)?</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The decorrelation time \(T_0\) assuming \(\Delta{}t=1\). </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00891">891</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65c0f6de77f3f7c59292e3f7b61c833d"></a><!-- doxytag: member="ar::decorrelation_time" ref="a65c0f6de77f3f7c59292e3f7b61c833d" args="(const std::size_t N, predictor&lt; Value &gt; rho1, predictor&lt; Value &gt; rho2, const bool abs_rho=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value ar::decorrelation_time </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">predictor&lt; Value &gt;&#160;</td>
          <td class="paramname"><em>rho1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">predictor&lt; Value &gt;&#160;</td>
          <td class="paramname"><em>rho2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>abs_rho</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the decorrelation time for a covariance given autocorrelation details from two processes. </p>
<p>That is, compute </p>
<p class="formulaDsp">
\begin{align} T_0 &amp;= 1 + 2 \sum_{i=1}^{N} \left(1 - \frac{i}{N}\right) \rho_{1,i} \rho_{2,i} \end{align}
</p>
<p> following Trenberth, K. E. "Some effects of finite sample size and
 persistence on meteorological statistics. Part I: Autocorrelations." Monthly Weather Review 112 (1984). <a href="http://dx.doi.org/10.1175/1520-0493(1984)112%3C2359:SEOFSS%3E2.0.CO;2">http://dx.doi.org/10.1175/1520-0493(1984)112%3C2359:SEOFSS%3E2.0.CO;2</a></p>
<p>Rather than \(\rho\), \(\left|\rho\right|\) may be used in the definition of \(T_0\) to better approximate the "decay of the correlation
 envelope" according to section 17.1.5 of Hans von Storch and Francis W. Zwiers. Statistical analysis in climate research. Cambridge University Press, March 2001. ISBN 978-0521012300. Doing so is more robust for oscillatory processes and always provides a larger, more conservative estimate of \(T_0\).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Maximum lag used to compute the autocorrelation. </td></tr>
    <tr><td class="paramname">rho1</td><td>A <a class="el" href="classar_1_1predictor.html">predictor</a> iterating over the <a class="el" href="namespacear.html#ad78566f1c965c4194cd93a5325544107">autocorrelation</a> for the first process. </td></tr>
    <tr><td class="paramname">rho2</td><td>A <a class="el" href="classar_1_1predictor.html">predictor</a> iterating over the <a class="el" href="namespacear.html#ad78566f1c965c4194cd93a5325544107">autocorrelation</a> for the first process. </td></tr>
    <tr><td class="paramname">abs_rho</td><td>Use \(\left|\rho\right|\) when calculating \(T_0\)?</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The decorrelation time \(T_0\) assuming \(\Delta{}t=1\). </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00940">940</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6649976e2fc0f7e0b6f80e48a2a5670"></a><!-- doxytag: member="ar::evaluate" ref="ac6649976e2fc0f7e0b6f80e48a2a5670" args="(Result sigma2e, Integer1 N, Integer2 p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Result , typename Integer1 , typename Integer2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result ar::evaluate </td>
          <td>(</td>
          <td class="paramtype">Result&#160;</td>
          <td class="paramname"><em>sigma2e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Evaluate a given <a class="el" href="structar_1_1criterion.html">criterion</a> for <code>N</code> samples and model order <code>p</code>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sigma2e</td><td>The residual \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The model order use to compute \(sigma^2_\epsilon\)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the evaluated criterion. </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l01615">1615</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a299e4eda569cae92a2a5192da4f2b6cb"></a><!-- doxytag: member="ar::evaluate_models" ref="a299e4eda569cae92a2a5192da4f2b6cb" args="(Integer1 N, Integer2 ordfirst, InputIterator first, InputIterator last, OutputIterator crit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer1 , typename Integer2 , class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;InputIterator&gt;::difference_type ar::evaluate_models </td>
          <td>(</td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>ordfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>crit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Algorithmic helpers for autoregressive model order selection. </p>
<p>Evaluate a <a class="el" href="structar_1_1criterion.html">criterion</a> on a hierarchy of models given \(\sigma^2_\epsilon\) for each model. The index of the best model, i.e. the one with minimum criterion value, is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ordfirst</td><td>The model order corresponding to <code>first</code>. When \(sigma^2_\epsilon\) is produced entirely by <a class="el" href="namespacear.html#a4464f8cff351885d447a5faada248cf6">burg_method</a>, this should be <code>0u</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the range holding \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of input range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crit</td><td>Value assigned to each model by the criterion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The distance from <code>first</code> to the best model. </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l02002">2002</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad337dfbd7bde87898f1f1206ef100d6c"></a><!-- doxytag: member="ar::evaluate_models" ref="ad337dfbd7bde87898f1f1206ef100d6c" args="(Integer1 N, Integer2 ordfirst, InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer1 , typename Integer2 , class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;InputIterator&gt;::difference_type ar::evaluate_models </td>
          <td>(</td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>ordfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the index of the best model from a hierarchy of candidates according to a <a class="el" href="structar_1_1criterion.html">criterion</a> given \(\sigma^2_\epsilon\) for each model. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ordfirst</td><td>The model order corresponding to <code>first</code>. When \(sigma^2_\epsilon\) is produced entirely by <a class="el" href="namespacear.html#a4464f8cff351885d447a5faada248cf6">burg_method</a>, this should be <code>0u</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the range holding \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of input range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The distance from <code>first</code> to the best model.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>evaluate_models(Criterion,Integer1,Integer2,InputIterator,OutputIterator) </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l02164">2164</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82454d2988b8b9f00cc3e14836bdc44e"></a><!-- doxytag: member="ar::welford_covariance_population" ref="a82454d2988b8b9f00cc3e14836bdc44e" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType1 &amp;mean1, OutputType2 &amp;mean2, OutputType3 &amp;covar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType1 , typename OutputType2 , typename OutputType3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_covariance_population </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>mean2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType3 &amp;&#160;</td>
          <td class="paramname"><em>covar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute means and the population covariance using Welford's algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first1</td><td>Beginning of the first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>Exclusive end of first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first2</td><td>Beginning of the second input range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean1</td><td>Mean of the first data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean2</td><td>Mean of the second data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covar</td><td>The covariance of the two sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number data values processed within <code>[first1, last2)</code>. </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00239">239</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p>References <a class="el" href="ar_8hpp_source.html#l00185">welford_ncovariance()</a>.</p>

</div>
</div>
<a class="anchor" id="a5f8569f8d184f8facaded6fa8220a41c"></a><!-- doxytag: member="ar::welford_covariance_sample" ref="a5f8569f8d184f8facaded6fa8220a41c" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType1 &amp;mean1, OutputType2 &amp;mean2, OutputType3 &amp;covar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType1 , typename OutputType2 , typename OutputType3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_covariance_sample </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>mean2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType3 &amp;&#160;</td>
          <td class="paramname"><em>covar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute means and the sample covariance using Welford's algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first1</td><td>Beginning of the first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>Exclusive end of first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first2</td><td>Beginning of the second input range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean1</td><td>Mean of the first data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean2</td><td>Mean of the second data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covar</td><td>The covariance of the two sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number data values processed within <code>[first1, last2)</code>. </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00269">269</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p>References <a class="el" href="ar_8hpp_source.html#l00185">welford_ncovariance()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a9004a99f24a6e0ac6ab2957be9e1e3"></a><!-- doxytag: member="ar::welford_ncovariance" ref="a8a9004a99f24a6e0ac6ab2957be9e1e3" args="(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType1 &amp;mean1, OutputType2 &amp;mean2, OutputType3 &amp;ncovar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType1 , typename OutputType2 , typename OutputType3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_ncovariance </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>mean2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType3 &amp;&#160;</td>
          <td class="paramname"><em>ncovar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute means and the number of samples, N, times the population covariance using Welford's algorithm. </p>
<p>The implementation follows the covariance section of <a href="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance.">http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance.</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first1</td><td>Beginning of the first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>Exclusive end of first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first2</td><td>Beginning of the second input range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean1</td><td>Mean of the first data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean2</td><td>Mean of the second data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ncovar</td><td>N times the covariance of the two sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number data values processed within <code>[first1, last2)</code>. </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00185">185</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa374873fb73eca704b72467f58a2a109"></a><!-- doxytag: member="ar::welford_nvariance" ref="aa374873fb73eca704b72467f58a2a109" args="(InputIterator first, InputIterator last, OutputType1 &amp;mean, OutputType2 &amp;nvar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputType1 , typename OutputType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_nvariance </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>nvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stable, one-pass algorithms for computing variances and covariances. </p>
<p>Compute the mean and the number of samples, N, times the population variance using Welford's algorithm. The latter quantity is effectively the centered sum of squares. The algorithm is found in Knuth's TAOCP volume 2 section 4.2.2.A on page 232. The implementation follows <a href="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance.">http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance.</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of the data in <code>[first, last)</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nvar</td><td>N times the variance of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number data values processed within <code>[first, last)</code>. </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00095">95</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6677588ce2c0685d9494e37d5c02209c"></a><!-- doxytag: member="ar::welford_variance_population" ref="a6677588ce2c0685d9494e37d5c02209c" args="(InputIterator first, InputIterator last, OutputType1 &amp;mean, OutputType2 &amp;var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputType1 , typename OutputType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_variance_population </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the mean and population variance using Welford's algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of the data in <code>[first, last)</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">var</td><td>The population variance of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N, the number data values processed within <code>[first, last)</code>. </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00133">133</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p>References <a class="el" href="ar_8hpp_source.html#l00095">welford_nvariance()</a>.</p>

</div>
</div>
<a class="anchor" id="a0df60aec47c7067dfe51d0892db50856"></a><!-- doxytag: member="ar::welford_variance_sample" ref="a0df60aec47c7067dfe51d0892db50856" args="(InputIterator first, InputIterator last, OutputType1 &amp;mean, OutputType2 &amp;var)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputType1 , typename OutputType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_variance_sample </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the mean and sample variance using Welford's algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of the data in <code>[first, last)</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">var</td><td>The sample variance of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N, the number data values processed within <code>[first, last)</code>. </dd></dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l00156">156</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p>References <a class="el" href="ar_8hpp_source.html#l00095">welford_nvariance()</a>.</p>

</div>
</div>
<a class="anchor" id="a70e8c90d3cdf5f3cf0a61e00751558b8"></a><!-- doxytag: member="ar::zohar_linear_solve" ref="a70e8c90d3cdf5f3cf0a61e00751558b8" args="(RandomAccessIterator a_first, RandomAccessIterator a_last, RandomAccessIterator r_first, InputIterator d_first, OutputIterator s_first)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ar::zohar_linear_solve </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>r_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>s_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve a Toeplitz set of linear equations. </p>
<p>That is, find \(s_{n+1}\) satisfying </p>
<p class="formulaDsp">
\[ L_{n+1} s_{n+1} = d_{n+1} \mbox{ where } L_{n+1} = \bigl(\begin{smallmatrix} 1 &amp; \tilde{a}_n \\ r_n &amp; L_n \end{smallmatrix}\bigr) \]
</p>
<p> given \(\vec{a}\), \(\vec{r}\), and \(\vec{d}\). The dimension of the problem is fixed by <code>n = distance(a_first, a_last)</code>. A symmetric Toeplitz solve can be performed by having \(\vec{a}\) and \(\vec{r}\) iterate over the same data. The Hermitian case requires two buffers with \(vec{r}\) being the conjugate of \(\vec{a}\). The working precision is fixed by the <code>value_type</code> of <code>d_first</code>.</p>
<p>The algorithm is from Zohar, Shalhav. "The Solution of a Toeplitz Set of
 Linear Equations." J. ACM 21 (April 1974): 272-276. <a href="http://dx.doi.org/10.1145/321812.321822.">http://dx.doi.org/10.1145/321812.321822.</a> It has complexity like <code>O(2*(n+1)^2)</code>. Zohar improved upon earlier work from Page 1504 from Trench, William F. "Weighting Coefficients for the Prediction of Stationary
 Time Series from the Finite Past." SIAM Journal on Applied Mathematics 15 (November 1967): 1502-1510. <a href="http://www.jstor.org/stable/2099503.See">http://www.jstor.org/stable/2099503.See</a> Bunch, James R. "Stability of Methods for Solving Toeplitz Systems of
 Equations." SIAM Journal on Scientific and Statistical Computing 6 (1985): 349-364. <a href="http://dx.doi.org/10.1137/0906025">http://dx.doi.org/10.1137/0906025</a> for a discussion of the algorithm's stability characteristics.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_first</td><td>Beginning of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_last</td><td>End of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_first</td><td>Beginning of the range containing \(\vec{r}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_first</td><td>Beginning of the range containing \(\vec{d}\) which should have <code>n+1</code> entries available. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s_first</td><td>Beginning of the output range to which <code>n+1</code> entries will be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l01003">1003</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb2d3771cb68bf77ddb8522eabf72c90"></a><!-- doxytag: member="ar::zohar_linear_solve" ref="acb2d3771cb68bf77ddb8522eabf72c90" args="(RandomAccessIterator a_first, RandomAccessIterator a_last, ForwardIterator d_first)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ar::zohar_linear_solve </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>d_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve a real-valued, symmetric Toeplitz set of linear equations in-place. </p>
<p>That is, compute </p>
<p class="formulaDsp">
\[ L_{n+1}^{-1} d_{n+1} \mbox{ for } L_{n+1} = \bigl(\begin{smallmatrix} 1 &amp; \tilde{a}_n \\ a_n &amp; L_n \end{smallmatrix}\bigr) \]
</p>
<p> given \(\vec{a}\) and \(\vec{d}\). The dimension of the problem is fixed by <code>n = distance(a_first, a_last)</code>. The working precision is fixed by the <code>value_type</code> of <code>d_first</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_first</td><td>Beginning of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_last</td><td>End of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_first</td><td>Beginning of the range containing \(\vec{d}\). Also the beginning of the output range to which <b><code>n+1</code></b> entries will be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l01181">1181</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p>References <a class="el" href="ar_8hpp_source.html#l01003">zohar_linear_solve()</a>.</p>

</div>
</div>
<a class="anchor" id="abca89c351017c0a7854258f4d5228221"></a><!-- doxytag: member="ar::zohar_linear_solve" ref="abca89c351017c0a7854258f4d5228221" args="(RandomAccessIterator a_first, RandomAccessIterator a_last, RandomAccessIterator r_first, ForwardIterator d_first)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ar::zohar_linear_solve </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>r_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>d_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Solve a Toeplitz set of linear equations in-place. </p>
<p>That is, compute </p>
<p class="formulaDsp">
\[ L_{n+1}^{-1} d_{n+1} \mbox{ for } L_{n+1} = \bigl(\begin{smallmatrix} 1 &amp; \tilde{a}_n \\ r_n &amp; L_n \end{smallmatrix}\bigr) \]
</p>
<p> given \(\vec{a}\), \(\vec{r}\), and \(\vec{d}\). The dimension of the problem is fixed by <code>n = distance(a_first, a_last)</code>. A symmetric Toeplitz solve can be performed by having \(\vec{a}\) and \(\vec{r}\) iterate over the same data. The Hermitian case requires two buffers with \(vec{r}\) being the conjugate of \(\vec{a}\). The working precision is fixed by the <code>value_type</code> of <code>d_first</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_first</td><td>Beginning of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_last</td><td>End of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_first</td><td>Beginning of the range containing \(\vec{r}\). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_first</td><td>Beginning of the range containing \(\vec{d}\). Also the beginning of the output range to which <b><code>n+1</code></b> entries will be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="ar_8hpp_source.html#l01148">1148</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p>References <a class="el" href="ar_8hpp_source.html#l01003">zohar_linear_solve()</a>.</p>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Fri Nov 9 2012 17:07:13 for github.com/RhysU/ar by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
